배워도 배워도 끝이 없는 SQL문법 select 함수...

아직도 많이 남았다고 합니다. ㅎㅎ

오늘도 내용정리 들어갑니다.

?

2일차 수업진행

  오전, 오후 - SQL select 함수, 문자함수

?

select 절의 풀 구문은 이러나 실제 해석하는 순서는 이렇습니다.

             select                  |                    from

               from                 |                  where

            where                 |                  group by

            group by            |                 having

           having                 |                   select

             order by           V                  order by

?

오늘 처음 배운 문법은 order by

 - asc 오름차순(디폴트 값) / desc 내림차순

  ex) order by 컬럼1, 컬럼2 desc;

 -> 컬럼1 기준 오름차순, 그 상태에서 컬럼2를 내림차순

 -> 정렬은 메모리를 많이 사용하기에 필요할 때만 하시기를

 -> 데이터 단위가 커질수록 정렬은 큰 시간이 걸리니 주의

?

함수 - 문자(이름, 날짜형식 등) / 숫자(표준편차 등)

        - 단일행함수(1 : 1 대응 처리) / 복수행함수(다 : 1 그룹 처리)

        - 단일행함수 : 인수를 사용해 값 반환, 중복 사용 가능

         -> 문자함수 : 문자열로 구성된 함수

           ex) upper, initcap, lower, length : 함수(컬럼 or '문자열');

       - 대문자, 첫글자만 대문자, 소문자, 길이

?

  substr(컬럼 or '문자열', m, [n]);

   - 원하는 글자를 원하는 곳 부터 추출하기 위함.

   - m = 시작위치, n = 추출개수

   - m < 0 : 뒤에서부터 추출, n 생략 시 끝까지 추출

   - 날짜에 추출하는건 비효율적(날짜 형식이 확실하지 않음)

?

   instr(컬럼 or '문자열', '찾는 문자열', [m], [n]);

   - 대상이 있는 위치를 추출함.

   - m = 시작위치, n = 반복번호

   - 추출 대상 탐색 방향이 역방향

   - 활용 예시 : '문자열' 위치, 지역번호, 이메일, 특정문자 포함여부

    -> substr과 instr 결합 시 다양한 활용도를 보임.

?

  lpad,rpad : 함수(컬럼 or '문자열', 전체 자리수, '채울문자');

   - pad 함수 채울 문자를 미입력할 경우 공백(띄어쓰기로 표현)

?

  ltrim,rtrim : 함수(컬럼 or '문자열', '제거할 문자');

   - 왼쪽이든 오른쪽이든 지우려는 글자는 처음에 와야함.

   - 다른 글자 지나가면 그 다음부터는 제거하지 않음.

?

  trim(컬럼 or '문자열');

   - 컬럼이나 '문자열'의 공백을 제거

   - 실무에서도 의외로 많이 생기는 실수로 데이터가 안읽어지면 의심하자!

?

  replace(컬럼 or '문자열', '단어1', '단어2');

   - 컬럼이나 '문자열'에서 단어를 다른 단어로 변경.

   - 단어의 치환이라 삭제도 가능.

?

  translate(컬럼 or '문자열', '문자1', '문자2');

   - 문자1 글자수 = 문자2 글자수 -> 그대로

     문자1 글자수  > 문자2 글자수 -> 문자1에서 삭제

     문자1 글자수  < 문자2 글자수 -> 문자2 뒤에 남는 부분을 무시

      -> 문자의 1:1 치환

      -> 응용할 경우 한번에 불필요한 글자, 중간에 들어온 공백 삭제 가능

       ex) translate(컬럼, '문자열에 없는 문자+문자1', '문자열에 없는 문자')

      -> 매칭 안되는 것 자동 삭제

?

sysdate 시스템 시간 - 툴의 날짜 표현 형식을 알 수 있음.

dual 가상의 테이블 -테이블이 없을 때 사용, 계산 바로 확인.

 ex) select 컬럼, 문자, 표현식(계산) from dual;

insert into 테이블(칼럼1, 칼럼2) values(칼럼1 값, 칼럼2 값);

commit; -데이터를 수정 후 저장.

ascii('한 글자'); - '한 글자'의 아스키 코드를 따옴.

?

cmd에서 사용

1. 관리자로 접속

sqlplus system/oracle

2. 유저2에게 유저1의 테이블을 선택하도록 허가

SQL> grant select on 유저1.테이블 to 유저2;

3. 유저1의 테이블에 공공의 별칭 생성

SQL> create public synonym 테이블 별칭 for 유저1.테이블;

?

날짜 형식 지정

alter session set nls_date_format='YYYY/MM/DD';

?

날짜는 불러오는 툴마다 표현 형식이 다른데

Orange 사용 시 날짜는 무조건 YYYY/MM/DD로 출력.

그러나 오라클을 통해 확인하면 YY/MM/DD로 출력.

이는 Orange 툴 자체적으로 날짜는 위의 형식으로 고정되도록 설정했기 때문.

?

가끔 어려운 문제는 있었으나 오늘까지도 큰 무리없이 참여했네요.

앞으로도 이정도 수준이기를 ㅎㅎ
[출처] [2일차] SQL 문법 정리 - select절 해석 순서, order by, substr, instr, trim, lpad, rpad, replace, translate|작성자 SNOW DONGHO


오늘로서 3일차 수업이 진행되었습니다.

처음 말씀하신것처럼 약 1주 간의 SQL 문법 수업이 진행될 예정입니다.

?

3일차 수업진행

 오전 - SQL 문법 숫자함수, 날짜함수

 오후 - SQL 문법 데이터 형 변환 함수, 일반함수

?

수업 내용

alter session set nls_date_format = '원하는 형식'으로 날짜를 변환출력

alter session set nls_date_language = '원하는 언어'로 날짜를 변환출력

alter(변환) session(부분) s2t(세팅) 이렇게는 외우시고 그 뒤에가 변경됨을 인지하시길

?

숫자함수

round(컬럼 or 표현식, 표현 원하는 자리수 or '날짜의 단위');

 ex) round(컬럼 or 표현식, n or 'month or year');

  소숫점 있는 숫자일 때 기준

 - n < 0 (십의 단위로 해당 자리에서 반올림)

 - n = 0 or 생략 (정수로 표현)

 - n > 0 (그만큼만 자리수 표현)

 날짜 기준

 - 뒤에 입력한 날짜 단위의 변동을 찾을 때 사용

  -> 'year'('month')일 경우 month(day)를 반올림해서 year을 알아야함.

?

 trunc(컬럼 or 표현식, 표현 원하는 자리수 or '날짜의 단위');

 - 버림함수

 - 나머지는 round 함수의 특성과 동일

?

mod(m, n);

 - m을 n으로 나누어 남은 값을 반환

?

floor(n);

 - 주어진 값보다 작거나 같은 최대 정수를 구함.(버려서 정수로 만들기)

?

ceil(n);

 - 주어진 값보다 크지만 가장 근접하는 최소값 구함.(올려서 정수로 만들기)

?

abs(n);

 - n의 절대값을 반환

?

sign(n);

 - 양수, 0, 음수를 각각 -1, 0, 1로 변환

 - n의 크기를 파악할 때 활용함

  ex) sign(n-m);

?

날짜함수

 - 날짜에 정수 연산이 가능한데 기본설정은 일 수를 계산함.

?

months_between(날짜1, 날짜2);

 - 두 날짜 간 개월 수 차이를 반환.

 - 보통 버림(trunc)해서 카운트 함.

 - 큰 날짜를 앞에 사용.

?

add_months(날짜, n);

 - 날짜 기준 n개월 이후 값 반환.

 - n < 0 : n개월 이전 값 반환.

?

next_day(날짜, '지정요일' or 숫자);

 - 숫자는 1이 일요일로 변환됨.('지정요일'은 기준 언어에 따라 '일' or 'sun')

 - 날짜 다음의 지정요일에 해당하는 날짜 반환.

?

last_day(날짜);

 - 해당 월의 마지막 날짜 반환.

?

데이터 형 변환 함수

1. to_char(바꿀대상, '원하는 변경 형태');

 - 숫자, 날짜를 문자로 변경함.

 - 문자로 변경을 원하는 것이기에 바꿀대상에는 문자가 올 수 없음.

 - 소숫점자리('09999.99'), 천단위('09,999'), 화폐기호($09,999.99) 등을 붙일 때 사용.

 - 숫자를 문자로 바꿀 경우 '원하는 변경 형태' 생략 가능(바꿀대상이 그대로 문자로만 변환됨.)

 - YYYY(연도), MM(월), DD(일),

   RRRR(1900년도 표시), Q(분기),

   DDTH(날짜 서수), DDSPTH(날짜 서수 영문),

   YEAR(연도 영문), MON(월 영문), DAY(요일 영문),

   HH24(24시간 기준 시간), HH(12시간 기준 시간)

  -> 영문의 경우 형식의 대소를 구분하기에 주의해서 사용(대소문자, 첫 글자만 대문자 가능)

 - MONTH로 변경시 길이가 달라지는 일 특히나 주의(like 함수 결과값이 안맞는 경우가 많음.)

 - 원하는 변경 형태에 문자가 올 경우 "문자" 사용.

?

참고사항

 - 컬럼이나 '문자열'에서 문자는 숫자를 포함하나 숫자는 문자를 포함할 수 없음.

 - ""를 쓰는 경우는 as함수 : "공 백", to_char : "문자 변경 형태"에 사용.

  wherer절 이용시 주의사항

 - 데이터를 가공할 때 컬럼을 가공하는 것보다 변수를 가공하는 것을 권유함.

  -> 차후 데이터 처리 속도에 큰 차이가 있음.

 - 문자 : 문자 / 숫자 : 숫자 조건 맞추는것이 좋음.(안될 경우 오류가 자주 남.)

?

    날짜의 파씽

2. to_date('날짜처럼 생긴 문자 or 숫자', '읽을 날짜 형식');

 - '날짜처럼 생긴 문자 or 숫자'를 '읽을 날짜 형식'으로 해석함.

 - to_chat와 활용시 - '문자 or 숫자로 된 날짜'를 날짜로 바꾼 후 그 출력되는 형식을 원하는 것으로 변경 가능.

 - 2000년 이후 생긴 모든 날짜 버그를 y2k라하며 이를 극복하기 위해 1900년 표시는 YYYY -> RRRR 사용.

 - 파생된 날짜는 디폴트 포맷에 맞게 출력됨.

 

   묵시적 형 변환(자동변환) : 오라클은 산술기호 사용 시 문자의 숫자 변환 가능 여부를 자동적으로 확인.

3. to_number('숫자처럼 생긴 문자');

 - '숫자처럼 생긴 문자'를 숫자로 변환

?

일반함수

nvl(컬럼, null일 경우 치환할 값 or '문자열');

 - 컬럼과 뒤의 치환할 값 or '문자열' 타입 같아야함.

 - 다를 경우 상수의 조건을 맞춰줘야함.(주로 to_char, to_date함수 사용.)

 - 컬럼의 데이터 타입을 리턴용 데이터의 기준 타입으로 함.

?

nvl2(컬럼, null 아닐 때 치환할 값, null일 때 치환할 값);

 - 컬럼과 null 아닐 때의 치환할 값의 데이터 타입 불일치를 허용.

  -> 다만 null 아닐 때의 치환할 값과 null일 때 치환할 값은 데이터 타입이 같아야함.

 - null이 아닐 때 치환할 값의 데이터 타입을 기준으로 함.

?

sql 내 if 구문을 대체하는 함수는 총 2가지(decode, case)

decode(함수식 입력)

 - decode는 특정 조건을 가진 문자를 치환.

  -> decode는 함수의 조건이 = 일 때 사용.

 - decode는 조건의 직접적인 대소비교가 불가능(case는 직접적인 대소비교 가능)

  -> 그러나 decode 함수도 sign 함수와 결합시 간접적인 대소비교가 가능

 - decode는 문법적으로 간단하나 속도가 느림.(case는 문법적으로 복잡하나 속도가 빠름.)

?

참고사항

CTRL - : 주석처리(해당 커서 한 라인, 혹은 드래그 영역)

CTRL SHIFT - : 주석해제

CTRL U : 드래그 영역 소문자 변경

CTRL SHIFT U : 드래그 영역 대문자 변경

CTRL SHIFT F : 드래그 쿼리 표준 포맷으로 줄 맞춤(오류 가능성 있음.)

CTRL 스크롤 업 : 글자 확대

CTRL 스크롤 다운 : 글자 축소

?

?

3일차 수업도 무사히 끝났습니다.

점차 SQL 문법에 익숙해지고 있으나 역시 단기간에 외울 함수들이 많은게 어렵네요.

처음 공부하실 때 문법들을 직접 쳐서 결과를 보면서 공부하시면 생각보다는 금방 외울 수 있는것 같습니다.

SQL 문법 공부하시는 분들 다들 힘내서 외워봐요
[출처] [3일차] SQL 문법 정리 - 날짜 파씽, round, trunc, sign, to_char, to_date, to_number, nvl, decode문|작성자 SNOW DONGHO

4일차 수업에 들어왔습니다.

어쩌다보니 새벽 4시에 일어나서 오늘 수업은 정말 힘들었습니다. ㅎㅎ

그래도 많이 안 놓치고 필기했으니 오늘도 한번 가보죠!

?

오늘 수업진행입니다.

 오전 - 조건함수, 그룹함수, group by 절, having 절

 오후 - join 함수

?

조건함수(속도측면을 중요시할지 or 간결성을 중요시할지)

 decode(A,B,1,null);

  - A가 B일때 1, 아니면 null

 - 인자에 제한이 없는 확장형 함수

 - 조건문이 축약된형식의 함수

 - 대소비교가 불가능(sign과 결합 시 극복 가능)

 - 조건의 검사대상이 1개일 때 사용.(A는 달라질 수 없음.)

 - decode 내 decode 함수를 활용해 조건 두 개를 만족할 수 있음.

 - 조건사용 시 데이터 타입을 찾워줄 것.(desc 테이블;로 사전 파악)

?

         if문,                         decode문,                         case문 비교

if A = 1 then 'a'       decode(A,1, 'a',       case when A = 1 then 'a'

   A = 2 then 'b'                           2, 'b',               when A = 2 then 'b'

   A = 3 then 'c'                           3, 'c',                when A = 3 then 'c'

               else 'd'                                'd');                                     else 'd'

                                                                        end;

 - if문은 SQL에는 없으나 차후 R,PYTHON에서 사용

 - case문은 조건의 검사대상이 달라져도 괜찮음(A,B,C, 등 가능)

 - A가 모두 같다면 case 앞으로 뺄 수 있음.

 - if문과 case문은 풀어서 써야함.

?

백터연산(R,PYTHON에서 사용)

 - 컬럼에 대한 단일행함수(1:1의 리턴)의 적용

 - R은 백터연산이 되나 PYTHON은 반복문을 써줘야 됨.

?

그룹함수(group by - 그룹별 조사절과 같이 쓰임.)

group by 컬럼1, 컬럼2;

 - 컬럼 1 기준 그룹짓고 그 상태에서 컬럼2 기준 추가 그룹 형성

  -> 가공된 컬럼도 사용 가능

 - 그룹함수를 사용하면 단일컬럼은 select절에 같이 못 씀.

  -> group by에 들어가는 컬럼은 사용 가능.

?

오라클은 안시표준(국제표준)과 다른 오라클 표준이 있음.

join 함수(서로 관련된 두 개 이상의 쿼리를 합침.)

 - where 테이블1.컬럼 = 테이블2.컬럼

  -> join 컬럼명은 다를 수 있으나 그 값은 겹쳐야함(서로 같은 형식 데이터).

 - 그룹함수 사용시 단일칼럼은 사용할 수 없음.

  -> group by절에서 사용하는 컬럼에 한하여 쓸 수 있음.

 - 데이터는 설계 목적에 따라 모델러에 의해서 목적을 가지고 나누어짐.

 - where절에 작성하며 3개 이상의 쿼리 사용시 and로 이음.

 - 테이블 이름이 길어질 경우 테이블 알리아스 사용 가능.

   ex) from 테이블 원하는테이블명.

  -> 테이블 알리아스를 사용할 경우 해당 절에 나온 모든 테이블명을 바꿔줘야함.

  -> 현업에서는 분류 단계가 많아져 테이블명이 길어지는 경우 다반사.

 - n개의 테이블 연결시 n-1개의 조건이 필요.

 - null이 있을 때 결과에서 생략(where절)

 - 카타시안 곱(cross join)

  -> n개의 행을 가진 테이블과 m개의 행 가진 테이블의 곱 n*m만큼의 경우의수가 나옴.

  -> where절이 유효하지 않을 경우 생길 수 있음.

 - equal join 조건(가장 선호되며 등가일 때 사용.)

 - non equal join 조건(부등식일 때 사용.)

?

outer join

 - join 함수(+) 붙이기

  -> 기준 테이블 확인 필요.(기준 테이블 반대에 (+)첨부)

   ex) where 테이블1.컬럼 = 테이블2.컬럼(+) - 테이블 1 기준일 때

 - join 조건이 맞지않아 생략되는 데이터도 출력함.

  -> null로 출력됨.

?

count(* or 컬럼);

 - null을 제외한 결과를 셈.

 - 전체를 셀 때  desc 중 not null인 컬럼 활용.

?

sum(합계)

?

avg(평균)

 - null을 제외한 평균값만 평균.

 - avg(nvl(comm,0)); : 전체에 대한 평균

 

min(최소값), max(최대값)

?

having 문법

 - group by가 선행된 이후의 조건을 넣을 때 사용.

 - where 조건에서 제외할 수 없는 내용에 대해 적응.

 - group에 관한 조건은 where 절에 사용할 수 없음.

  ex) count, sum, avg, min,max
[출처] [4일차] SQL 문법 정리 - decode문, if문, case문, 오라클 표준, having, 그룹함수|작성자 SNOW DONGHO

어제는 너무 졸린 나머지 내용만 정리하고 자버렸네요. ㅎㅎ

확실히 안하던 공부를 다시 할라니까 힘들기도하고

처음 배우는 내용들이 쏟아지니 의지가... ㅋㅋㅋ

어쨌든 최대한 밀리지않게 올려보겠습니다.

?

어제는 사실상 join에 대한 내용이 주였고 평소보다 실습이 많아서

내용적인 측면은 상대적으로 적었습니다.

그럼에도 풀어본 문제들의 난이도는 평소보다도 더 높은 느낌이 컸어요.

그만큼 어려운 내용이라는거겠죠?

?

수업진행

 오전 오후 : join

?

non-equal join(부등호가 아닌 모든 조건)

 - 몇 개의 쿼리를 합치던 무관하며 상관된 조건 작성이 중요.

?

outer join

 - 양쪽 컬럼 중 하나가 null이 있지만 출력해야할 때 사용.

  -> non-equal join에서는 join 조건이 안맞은 것 출력할 때 사용.

 - 기준 테이블 반대편에 (+) 기호 사용.

  -> 기준 테이블에 붙는것과 아닌 것은 차이가 생김.

 - 오라클은 from절에 join하는 테이블 순서가 무관함.

  -> 국제표준인 안시표준에서는 left, right를 나누기에 순서는 중요함.

?

self join

 - 동일한 테이블 내에 원하는 정보를 한번에 가져올 수 없을 때.

  -> 한 행과 전체의 두 번의 스캔이 필요한 경우.

  -> 서로 다른 테이블처럼 join을 걸어줌.

 - A보다 더 ~한 사람을 구하라.

?

sub query

 - 메인쿼리 내 또 다른 쿼리를 만듬.

  ex) select col1, (select...) : 스칼라 서브쿼리 : 하나의 컬럼으로 사용.

          from           (select...) : 인라인 뷰 : 하나의 테이블처럼 사용.

        where col1, (select...) : 일반 서브쿼리 : 한의 변수(상수)처럼 사용.

 - where절에는 그룹함수가 못 들어감.

  -> 그룹함수를 불러올 경우 알리아스로 수정해서 불러야함.

 - 출력한 함수 결과에 대해 세부정보가 알고싶을 때 사용.

?

group by에 컬럼을 써야 select절에 컬럼을 올릴  수 있음.

 ex) select 컬럼1(group by에 있는), 컬럼2(group by에 있는)

         from 테이블

       where 조건

        group by 컬럼1, 컬럼2;

 - 겹치는 내용이라도 group by에 여러 컬럼 쓰는 경우가 있음.

  ex) 이름, 학점, 학년 등(null값만 없으면 사용 가능)

  -> 동명이인 문제를 해결하기 위함.(이름은 위험한 컬럼)

  -> 그룹별 연산을 방해하지 않는 범위에서만 사용.

 - 식별용 컬럼을 넣어주면 좋음.(타인과 중복 안되는 것.)

  ex) 학번, 군번, 사원번호, 회원번호, 주민번호 등(1인당 1개 주는 것)

?

order by에는 컬럼 대신 출력되는 컬럼의 순서(select절 순서)를 쓸수도 있음.

 ex) order by 2,1;

  -> select절의 두번째 컬림 기준 정렬 후 첫번째 컬럼 기준정렬이 나옴.

  -> 이전에 말씀드린 select절의 순서와 연관됩니다.

   select절 해석순서 (from -> where -> group by -> having -> select -> order by)

?

참고사항

 - 그룹별 연산 시에는 데이터가 먼저 생성되어야함.

 - 데이터 삭제 방법

   ex) delete 테이블명 where 컬럼 = 지울 컬럼 내용;

          commit;

  -> commit;까지 해줘야 실제 데이터에 적용이 된것입니다.

      commit;을 안할 경우 일시적으로 삭제된 것으로 보이나 실제 데이터가 삭제된 것은 아닙니다.
[출처] [5일차] SQL 문법 정리 - outer join, self join, 서브쿼리, group by, order by|작성자 SNOW DONGHO

어제는 송년회로 글을 올릴 생각도 하지 못했네요. ㅎㅎ

연말이 되다보니 하루하루 일정이 많아집니다.

다시 마음잡고 올리겠습니다.

?

참고로 이번이 저희 수업 커리큘럼상 마지막 SQL수업입니다.

3개월 반이라는 짧은 수강기간동안 많은 내용을 진행하기에

아쉽지만 어느정도의 내용은 넘어갈 수 밖에 없다고 합니다.

?

그럼 6일차 정리하겠습니다.

오늘은 가장 어려운 join 함수들에 대해 정리했습니다.

수업 내용을 듣고 따라갈 때는 이게 왜 어렵지??

이런 느낌이었는데 막상 혼자서 문제를 풀라니까 감이 안잡히네요. ㅎㅎ

?

6일차 내용입니다.

 오전, 오후 : join함수 및 서브쿼리

?

 outer join

 - join조건에 함수가 나올 때는 괄호 안의 컬럼 옆에 (+) 기호 붙이기.

  -> 컬럼이 다수일 경우 기준 반대편에 있는 모든 컬럼에 (+)기호 붙이기

 ex) s1 - s2(s1 기준으로 s2 정보를 얻어야함.)

       s1 - p(si 기준으로 p 정보를 얻어야함.)

       d - s1(d 기준으로 s1 정보를 얻어야함.)

 구조화

      d    -   s1  - s2

                 |

                p

     -> s1 - s2(+) -> s1 - p(+) -> d - s1(+)

     -> s1(+)

?

 ex) s1 - s2(s1 기준으로 s2 정보를 얻어야함.)

        s2 - p(s2 기준으로 p 정보를 얻어야함.)

 구조화

     s1 - s2 - p

    ->  s1 - s2(+) -> s2(+) - p(+)

?

 ex) s1 - e1

        |       |

       s2 - e2

  구조화

      s1 - s2 - e2 - e1 - s1...

     -> s1 - s2(+) -> s2(+) - e2(+) -> e2(+) - e1(+)

     -> e1(+) -> s1(+) -> ...

   - 모두가 outer join이 되는 것을 순환고리라하며 에러가 남.

   - subquery 활용해서 해결함.

?

join과 subquery를 이해하기 위해서는 먼저 컴퓨터가 계산하는 방식에 대한 이해가 필요

 - 오라클은 특히나 데이터를 한 행씩 처리함.

1. 스칼라(하나의) 서브쿼리

 - select절에 subquery 사용해 하나의 컬럼처럼 사용.

 - join의 대체 표현식으로 자주 사용함.

 - 속도적인 측면에서 불리함.

 - 스칼라 서브쿼리는 메인 쿼리의 정보(테이블)를 이미 알고있음.

  -> 오라클 select절 해석 순서와 연관.

 - where절에 조건이 없기에 값이 없어도 출력함.

  -> self join과의 차이로 이미 outer join이 적용된 상태로 출력됨.

?

2. 다중 컬럼 서브쿼리(그룹별 대소 불가능)

  - 비교대상이 두 가지일 때 사용했으나 막상 하나가 필요없는 표현임.

   -> 컬럼에 그룹을 만들어서 사용.

   -> 인라인 부와 같은 원리로 사용됨.

   -> 인라인 뷰와 같은 원리로 사용됨.

 - select절에 개인의 정보를 출력할 때 group by를 쓸 수 없군

 - 그룹별 대소비교 불가능

  -> 인라인 뷰 사용해야함.

?

3, 상호 연관 서브쿼리(그룹별 대소비교 가능)

 메인쿼리와 서브쿼리가 계속해서 상호 정보를 주고받음.

  -> 데이터가 많아질수록 속도측면에서 불리

 - group by의 의미가 없어짐.

   -> 이미 where절에서 각 행별로 연산을 실시하기 때문.'

   -> 하나의 결과값만 나오게 됨.

 

?

4. from절에 사용(인라인 뷰)

  ex) s1e1 - s2e2

   -> 두 테이블을 하나의 테이블로 묶음(from절에 subquery 사용.)

   -> 데이터 간 관계 파악이 중요함.

  - where절에 함수 사용할 경우 subquery절의 select절에 알리안스 사용해서 빼옴.

  -> 테이블을 가지고 있다고 가상으로 전제함.

?

5. where절에 사용(다중행 서브쿼리)

  ex) where 컬럼 > (select 컬럼 from 테이블 where 조건)

   -> 상수를 대체하기 위함.(상수가 변하는 경우 조건)

 - 다중행 서브쿼리(where절)에서 =은 in으로 대체됨.

  ex) where 컬럼 > any나 all(값)

   -> 서브쿼리의 대소비교는 any(의미상 or)나 all(의미상 and)로 대체됨.

   -> where절에 min, max 등의 함수가 올 수 없기에 사용.

   -> subquery 내 select절에 쓸 수 있기에 중요하지 않음.

 - 특별한 경우 제외 subquery에는 order by 전혀 쓸 필요 없음.

  -> 최종 출력결과에 사용함.

?

튜닝(구조적 튜닝, 문법적 튜닝)

index(튜닝의 핵심)

 - 저장된 데이터의 주소를 통해 불러옴.

  ->rowid 컬럼(행마다의 주소값)

문법적 튜닝

 - 불필요한 쿼리 제거, order by 제거

뷰

 - 테이블은 아니지만 테이블 형식을 갖춘 정보

sequence

 - 일련번호를 지정

  -> 게시글 번호, 주문번호, 송장번호 등

synonym

 - 테이블명을 다르게 지정해줌.(알리아스와 비슷한 개념.)

?

데이터 변경 언어

insert

update

delete

 - 원하는 데이터를 선택해서 날림.

commit;(데이터 변경 후에는 확정이 필요.)

rollback;(데이터 확정 후 취소)

create 테이블 ddl_test(테이블 저장 / CTAS 다른 이름으로 저장)

 - (no

name

birth)

as

selected * from(새로운)테이블명

 - CTAS를 통해서 주로 백업을 함.

 - CTAS의 where절을 읽히지 않게하면 구조만 가져올 수 있음.

drop 테이블;

 - 테이블을 구조까지 완전히 날림.

truncate 테이블;

 - 테이블 구조는 남기고 데이터만 날려버림.

constraint

 - 테이블 컬럼마다 지정하는 규칙

 -> not flll(널값 안됨.), unique(중복 금지), primary key(not null + unique, 식별자)

 foreign key(다른 테이블 참조), check(조건 범위만 허용)

?

집합연산자

 - 행을 합치는 과정

 - 두 데이터 셋의 합집합, 교집합, 차집합 연산

 - select와 select 사이에 집합 연산자 나열

 - 데이터 타입은 일치시켜야하며 컬럼 개수도 같아야함.

  -> 간혹 아래의 데이터가 컬럼개수가 적을 때는 나오기도 함.

 - 합집합

  -> union : 교집합되는 부분을 한번만 출력(자동 sorting 작업으로 자료 많으면 느려짐)

  -> union all : 교집합되는 부분을 전체 다 출력(sorting 없이 바로 표현하기에 속독다 빠름)

 - 교집합

  -> intersect

 - 차집합

  -> minus : A에서 B와 교집합 되는 부분을 뺀 값을 보여주기에 순서가 중요함.

?

참고사항

드래그 후 CTRL + L : 드래그 영역만 실행.
[출처] [6일차] SQL 문법 정리 - outer join, 스칼라 서브쿼리, 다중 컬럼 서브쿼리, 상호 연관 서브쿼리, 인라인 뷰, 집합연산자|작성자 SNOW DONGHO